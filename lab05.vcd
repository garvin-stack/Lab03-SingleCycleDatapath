$date
	Fri May 12 23:19:16 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module alu $end
$var wire 4 ! alu_control_in [3:0] $end
$var wire 32 " channel_a_in [31:0] $end
$var wire 32 # channel_b_in [31:0] $end
$var reg 32 $ alu_result_out [31:0] $end
$var reg 32 % temp [31:0] $end
$var reg 1 & zero_out $end
$upscope $end
$scope module alu_control $end
$var wire 2 ' alu_op [1:0] $end
$var wire 6 ( instruction_5_0 [5:0] $end
$var reg 4 ) alu_out [3:0] $end
$upscope $end
$scope module control_unit $end
$var wire 6 * instr_op [5:0] $end
$var reg 2 + alu_op [1:0] $end
$var reg 1 , alu_src $end
$var reg 1 - branch $end
$var reg 1 . mem_read $end
$var reg 1 / mem_to_reg $end
$var reg 1 0 mem_write $end
$var reg 1 1 reg_dst $end
$var reg 1 2 reg_write $end
$upscope $end
$scope module cpu_registers $end
$var wire 1 3 clk $end
$var wire 32 4 read_data_1 [31:0] $end
$var wire 32 5 read_data_2 [31:0] $end
$var wire 5 6 read_register_1 [4:0] $end
$var wire 5 7 read_register_2 [4:0] $end
$var wire 1 8 reg_write $end
$var wire 1 9 rst $end
$var wire 32 : write_data [31:0] $end
$var wire 5 ; write_register [4:0] $end
$var integer 32 < i [31:0] $end
$upscope $end
$scope module cpumemory $end
$var wire 1 = clk $end
$var wire 8 > data_address [7:0] $end
$var wire 1 ? data_mem_write $end
$var wire 32 @ data_read_data [31:0] $end
$var wire 32 A data_write_data [31:0] $end
$var wire 32 B instr_instruction [31:0] $end
$var wire 8 C instr_read_address [7:0] $end
$var wire 1 D rst $end
$upscope $end
$scope module mux_2_1 $end
$var wire 32 E datain1 [31:0] $end
$var wire 32 F datain2 [31:0] $end
$var wire 1 G select_in $end
$var wire 32 H data_out [31:0] $end
$upscope $end
$scope module processor_tb $end
$var wire 6 I instr_opcode [5:0] $end
$var wire 5 J reg1_addr [4:0] $end
$var wire 32 K reg1_data [31:0] $end
$var wire 5 L reg2_addr [4:0] $end
$var wire 32 M reg2_data [31:0] $end
$var wire 5 N write_reg_addr [4:0] $end
$var wire 32 O write_reg_data [31:0] $end
$var wire 32 P prog_count [31:0] $end
$var reg 1 Q clk $end
$var reg 1 R rst $end
$var integer 32 S passedTests [31:0] $end
$var integer 32 T totalTests [31:0] $end
$scope module uut $end
$var wire 1 Q clk $end
$var wire 6 U instr_opcode [5:0] $end
$var wire 32 V prog_count [31:0] $end
$var wire 5 W reg1_addr [4:0] $end
$var wire 32 X reg1_data [31:0] $end
$var wire 5 Y reg2_addr [4:0] $end
$var wire 32 Z reg2_data [31:0] $end
$var wire 1 R rst $end
$var wire 5 [ write_reg_addr [4:0] $end
$var wire 32 \ write_reg_data [31:0] $end
$var wire 32 ] next_pc [31:0] $end
$var wire 32 ^ curr_pc [31:0] $end
$scope module programcounter $end
$var wire 1 Q clk $end
$var wire 32 _ data_in [31:0] $end
$var wire 1 R rst $end
$var wire 1 ` write_en $end
$var reg 32 a data_out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0 a
1`
b100 _
b0 ^
b100 ]
bz \
bz [
bz Z
bz Y
bz X
bz W
b0 V
bz U
b0 T
b0 S
1R
0Q
b0 P
bz O
bz N
bz M
bz L
bz K
bz J
bz I
bz H
zG
bz F
bz E
zD
bz C
bx B
bz A
bx @
z?
bz >
z=
bx <
bz ;
bz :
z9
z8
bz 7
bz 6
bx 5
bx 4
z3
02
01
00
0/
0.
0-
0,
b0 +
bz *
b10 )
bz (
bz '
1&
b0 %
b0 $
bz #
bz "
bz !
$end
#50000
1Q
#100000
0R
0Q
#105000
b1000 ]
b1000 _
b100 P
b100 V
b100 ^
b100 a
1Q
#110000
0Q
#115000
b1100 ]
b1100 _
b1000 P
b1000 V
b1000 ^
b1000 a
1Q
#116000
b1 T
#120000
0Q
#125000
b10000 ]
b10000 _
b1100 P
b1100 V
b1100 ^
b1100 a
1Q
#126000
b10 T
#130000
0Q
#135000
b10100 ]
b10100 _
b10000 P
b10000 V
b10000 ^
b10000 a
1Q
#136000
b11 T
#140000
0Q
#145000
b11000 ]
b11000 _
b10100 P
b10100 V
b10100 ^
b10100 a
1Q
#146000
b100 T
#150000
0Q
#155000
b11100 ]
b11100 _
b11000 P
b11000 V
b11000 ^
b11000 a
1Q
#156000
b101 T
#160000
0Q
#165000
b100000 ]
b100000 _
b11100 P
b11100 V
b11100 ^
b11100 a
1Q
#166000
b110 T
